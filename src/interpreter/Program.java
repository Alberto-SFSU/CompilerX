package interpreter;

import java.util.HashMap;
import java.util.Vector;

import interpreter.bytecodes.BranchingByteCode;
import interpreter.bytecodes.ByteCode;
import interpreter.bytecodes.LabelCode;

/**
 * Holds the bytecode objects and has a method to resolve addresses for branch instructions.
 * 
 * @author Alberto Mancini
 */
public class Program {
	private Vector<ByteCode> bytecodes;
	private HashMap<String, Integer> symAddrs;
	
	public Program() {
		bytecodes = new Vector<>();
		symAddrs = new HashMap<>();
	}

	public void addCode(ByteCode bytecode) {
		bytecodes.add(bytecode);
		
		//track labels for branches
		if(bytecode instanceof LabelCode) {
			symAddrs.put(((LabelCode) bytecode).getLabel(), bytecodes.size()-1); //<<label>, index>
		}
	}
	
	public ByteCode getCode(int i) {
		return bytecodes.get(i);
	}
	
	/**
	 * Walks through the generated ByteCodes and resolves any symbolic addresses
	 * to a numeric ByteCode address of the target (index in bytecodes vector).
	 */
		public void resolveAddress() {
			for(ByteCode bytecode : bytecodes) {
				if(bytecode instanceof BranchingByteCode) {
					BranchingByteCode branchingCode = (BranchingByteCode) bytecode;
					branchingCode.jumpToBranch(symAddrs.get(branchingCode.getLabel()));
				}
			}
		}
}
